#!/usr/bin/env python3
"""
Generate Swagger/OpenAPI documentation for Gin project.
"""

import argparse
import sys
from pathlib import Path


def get_swagger_annotations() -> str:
    """Get Swagger annotations template."""
    return r"""// Package docs GENERATED BY SWAG; DO NOT EDIT
// This file was generated by swaggo/swag
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "swagger": "2.0",
    "info": {
        "description": "{{.Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {}
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &swag.Spec{
	Version:          "1.0",
	Host:             "localhost:8080",
	BasePath:         "/api/v1",
	Schemes:          []string{},
	Title:            "API Documentation",
	Description:      "API documentation for the application",
	InfoInstanceName: "swagger",
	SwaggerTemplate:  docTemplate,
}

func init() {
	swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}
"""


def get_main_annotations() -> str:
    """Get main.go Swagger annotations."""
    return """
// Add these annotations at the top of your main.go file:

// @title           API Documentation
// @version         1.0
// @description     This is the API documentation for your application
// @termsOfService  http://swagger.io/terms/

// @contact.name   API Support
// @contact.url    http://www.swagger.io/support
// @contact.email  support@swagger.io

// @license.name  Apache 2.0
// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html

// @host      localhost:8080
// @BasePath  /api/v1

// @securityDefinitions.apikey Bearer
// @in header
// @name Authorization
// @description Type "Bearer" followed by a space and JWT token.

func main() {
    // Your existing code...
}
"""


def get_handler_example() -> str:
    """Get handler example with Swagger annotations."""
    return """
// Example handler with Swagger annotations:

// GetUser godoc
// @Summary      Get user by ID
// @Description  Get user details by user ID
// @Tags         users
// @Accept       json
// @Produce      json
// @Param        id   path      string  true  "User ID"
// @Success      200  {object}  entity.User
// @Failure      400  {object}  response.ErrorResponse
// @Failure      404  {object}  response.ErrorResponse
// @Failure      500  {object}  response.ErrorResponse
// @Router       /users/{id} [get]
// @Security     Bearer
func (h *UserHandler) GetUser(c *gin.Context) {
    id := c.Param("id")
    
    user, err := h.usecase.GetByID(c.Request.Context(), id)
    if err != nil {
        c.JSON(http.StatusNotFound, response.Error("User not found"))
        return
    }
    
    c.JSON(http.StatusOK, response.Success(user))
}

// CreateUser godoc
// @Summary      Create new user
// @Description  Create a new user with the provided information
// @Tags         users
// @Accept       json
// @Produce      json
// @Param        request  body      CreateUserRequest  true  "User information"
// @Success      201      {object}  entity.User
// @Failure      400      {object}  response.ErrorResponse
// @Failure      500      {object}  response.ErrorResponse
// @Router       /users [post]
// @Security     Bearer
func (h *UserHandler) CreateUser(c *gin.Context) {
    var req CreateUserRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, response.Error(err.Error()))
        return
    }
    
    user, err := h.usecase.Create(c.Request.Context(), &req)
    if err != nil {
        c.JSON(http.StatusInternalServerError, response.Error(err.Error()))
        return
    }
    
    c.JSON(http.StatusCreated, response.Success(user))
}

// UpdateUser godoc
// @Summary      Update user
// @Description  Update user information
// @Tags         users
// @Accept       json
// @Produce      json
// @Param        id       path      string             true  "User ID"
// @Param        request  body      UpdateUserRequest  true  "User information"
// @Success      200      {object}  entity.User
// @Failure      400      {object}  response.ErrorResponse
// @Failure      404      {object}  response.ErrorResponse
// @Failure      500      {object}  response.ErrorResponse
// @Router       /users/{id} [put]
// @Security     Bearer
func (h *UserHandler) UpdateUser(c *gin.Context) {
    // Implementation...
}

// DeleteUser godoc
// @Summary      Delete user
// @Description  Delete user by ID
// @Tags         users
// @Accept       json
// @Produce      json
// @Param        id   path      string  true  "User ID"
// @Success      200  {object}  response.SuccessResponse
// @Failure      400  {object}  response.ErrorResponse
// @Failure      404  {object}  response.ErrorResponse
// @Failure      500  {object}  response.ErrorResponse
// @Router       /users/{id} [delete]
// @Security     Bearer
func (h *UserHandler) DeleteUser(c *gin.Context) {
    // Implementation...
}

// ListUsers godoc
// @Summary      List users
// @Description  Get list of users with pagination
// @Tags         users
// @Accept       json
// @Produce      json
// @Param        page      query     int     false  "Page number"  default(1)
// @Param        per_page  query     int     false  "Items per page"  default(10)
// @Param        search    query     string  false  "Search query"
// @Success      200       {object}  response.PaginatedResponse{data=[]entity.User}
// @Failure      400       {object}  response.ErrorResponse
// @Failure      500       {object}  response.ErrorResponse
// @Router       /users [get]
// @Security     Bearer
func (h *UserHandler) ListUsers(c *gin.Context) {
    // Implementation...
}
"""


def get_response_models() -> str:
    """Get response models for Swagger."""
    return r"""package response

// SuccessResponse represents a successful response
type SuccessResponse struct {
	Success bool        `json:"success" example:"true"`
	Data    interface{} `json:"data"`
}

// ErrorResponse represents an error response
type ErrorResponse struct {
	Success bool   `json:"success" example:"false"`
	Error   string `json:"error" example:"Error message"`
}

// PaginatedResponse represents a paginated response
type PaginatedResponse struct {
	Success    bool        `json:"success" example:"true"`
	Data       interface{} `json:"data"`
	Page       int         `json:"page" example:"1"`
	PerPage    int         `json:"per_page" example:"10"`
	TotalPages int         `json:"total_pages" example:"5"`
	TotalItems int64       `json:"total_items" example:"50"`
}

// Success returns a success response
func Success(data interface{}) SuccessResponse {
	return SuccessResponse{
		Success: true,
		Data:    data,
	}
}

// Error returns an error response
func Error(message string) ErrorResponse {
	return ErrorResponse{
		Success: false,
		Error:   message,
	}
}

// Paginated returns a paginated response
func Paginated(data interface{}, page, perPage, totalPages int, totalItems int64) PaginatedResponse {
	return PaginatedResponse{
		Success:    true,
		Data:       data,
		Page:       page,
		PerPage:    perPage,
		TotalPages: totalPages,
		TotalItems: totalItems,
	}
}
"""


def create_docs_structure(project_path: Path):
    """Create documentation structure."""
    print("\nüöÄ Generating Swagger documentation structure\n")
    
    # Create docs directory
    docs_dir = project_path / "docs"
    docs_dir.mkdir(exist_ok=True)
    
    # Create docs.go
    docs_file = docs_dir / "docs.go"
    docs_file.write_text(get_swagger_annotations())
    print("‚úì Created docs/docs.go")
    
    # Update response package
    response_dir = project_path / "pkg" / "response"
    response_dir.mkdir(parents=True, exist_ok=True)
    
    response_file = response_dir / "response.go"
    if not response_file.exists():
        response_file.write_text(get_response_models())
        print("‚úì Created pkg/response/response.go")
    else:
        print("‚ö† pkg/response/response.go already exists, skipping")
    
    # Create examples directory
    examples_dir = project_path / "docs" / "examples"
    examples_dir.mkdir(exist_ok=True)
    
    # Create example files
    main_example = examples_dir / "main_annotations.txt"
    main_example.write_text(get_main_annotations())
    print("‚úì Created docs/examples/main_annotations.txt")
    
    handler_example = examples_dir / "handler_annotations.txt"
    handler_example.write_text(get_handler_example())
    print("‚úì Created docs/examples/handler_annotations.txt")
    
    print("\nüì¶ Required dependencies:")
    deps = [
        "github.com/swaggo/swag/cmd/swag",
        "github.com/swaggo/gin-swagger",
        "github.com/swaggo/files",
    ]
    for dep in deps:
        print(f"   - {dep}")
    
    print("\nüìù Installation steps:")
    print("   1. Install swag CLI:")
    print("      go install github.com/swaggo/swag/cmd/swag@latest")
    print("\n   2. Install dependencies:")
    print(f"      go get {' '.join(deps[1:])}")
    
    print("\n‚úÖ Documentation structure created successfully!")
    print("\nüìñ Next steps:")
    print_next_steps()


def print_next_steps():
    """Print next steps for documentation."""
    print("""
1. Add Swagger annotations to your main.go:
   - See docs/examples/main_annotations.txt

2. Add Swagger annotations to your handlers:
   - See docs/examples/handler_annotations.txt

3. Generate Swagger documentation:
   swag init -g cmd/api/main.go

4. Add Swagger route to your main.go:
   import (
       swaggerFiles "github.com/swaggo/files"
       ginSwagger "github.com/swaggo/gin-swagger"
       _ "yourproject/docs"  // Import generated docs
   )
   
   func main() {
       r := gin.Default()
       
       // Swagger documentation
       r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
       
       // Your routes...
   }

5. Run your application and visit:
   http://localhost:8080/swagger/index.html

6. Regenerate docs after changes:
   swag init -g cmd/api/main.go
""")


def main():
    parser = argparse.ArgumentParser(description="Generate Swagger documentation for Gin project")
    parser.add_argument("--project-path", default=".", help="Path to project root")
    
    args = parser.parse_args()
    
    project_path = Path(args.project_path)
    if not project_path.exists():
        print(f"‚úó Error: Project path '{args.project_path}' does not exist")
        sys.exit(1)
    
    # Check if it's a Go project
    if not (project_path / "go.mod").exists():
        print(f"‚úó Error: Not a Go project (go.mod not found)")
        sys.exit(1)
    
    create_docs_structure(project_path)


if __name__ == "__main__":
    main()

